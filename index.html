<div style="display: flex;">
    <div id="sidebar" style="width: 200px; height: 810px; background: #e0e0e0; padding: 10px; font-family: Arial, sans-serif;">
        <div id="turn-info" style="margin-bottom: 10px;"></div>
        <button id="done-button" style="display: none; width: 100%; padding: 5px;">Done</button>
    </div>
    <div>
        <div id="status-bar" style="width: 800px; height: 30px; background: #f0f0f0; text-align: center; line-height: 30px; font-family: Arial, sans-serif;">
            <span id="generation">Generation: 0</span> |
            <span id="team0">Neutral: 0%</span> |
            <span id="team1">Red: 0%</span> |
            <span id="team2">Blue: 0%</span>
        </div>
        <canvas id="gc" width="800" height="800" style="display: block;"></canvas>
    </div>
</div>
<script>

// using old-school module pattern for lightweight way to handle scope problems
const GameOfLife = (function () {
    // game logic constants
    const LIVE_SURVIVE = [2, 3];
    const DEAD_REBORN = [3];
    const GENERATION_LENGTH = 50;
    const GENERATIONS_BETWEEN_TURNS = 50;
    const BASE_BUFFER = 30;
    const MAX_PICKS = 5;
    // not technically number of statics, but close enough
    const NUM_STATICS_AT_START = 30;

    // Private state
    let liveCells = new Set();
    let running = false;
    let pausePending = false;
    let intervalId = null;
    let generation = 0;
    let turnPhase = "team2"; // Start with Blue's turn
    let team2Picks = new Set();
    let team1Picks = new Set();

    // DOM setup (private)
    const canv = document.getElementById("gc");
    const ctx = canv.getContext("2d");
    const CELL_SIZE = 10;
    const NUM_CELLS_IN_ROW = canv.width / CELL_SIZE;
    const LOWER_BOUND = -50;
    const UPPER_BOUND = NUM_CELLS_IN_ROW + (-1 * LOWER_BOUND);

    // UI DOM refs
    const generationSpan = document.getElementById("generation");
    const team0Span = document.getElementById("team0");
    const team1Span = document.getElementById("team1");
    const team2Span = document.getElementById("team2");
    const turnInfo = document.getElementById("turn-info");
    const doneButton = document.getElementById("done-button");

    // UI constants
    const CELL_COLOR_0 = "Black";
    const CELL_COLOR_1 = "Red";
    const CELL_COLOR_2 = "Blue";
    const GRID_LINE_COLOR = "DarkGray";
    const GRID_BACKGROUND_COLOR = "Beige";

    // patterns
    const block = [
        [0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 0, 3],
        [0, 1, 0], [1, 1, 1], [1, 1, 2], [0, 1, 3],
        [0, 2, 0], [1, 2, 1], [1, 2, 2], [0, 2, 3],
        [0, 3, 0], [0, 3, 1], [0, 3, 2], [0, 3, 3]
    ];
    // Initialize the game
    function init() {
        document.addEventListener("click", handleClick);
        document.addEventListener("keydown", handleKeyPress);
        doneButton.addEventListener("click", handleDoneClick);
        initialState();
    }

    // Event handlers
    function handleClick(event) {
        if (running || turnPhase === "running") return;
        const rect = canv.getBoundingClientRect();
        const x = Math.floor((event.clientX - rect.left) / CELL_SIZE);
        const y = Math.floor((event.clientY - rect.top) / CELL_SIZE);
        const team = turnPhase === "team2" ? 2 : 1;
        const cellKey = `${team},${x},${y}`;
        const picks = turnPhase === "team2" ? team2Picks : team1Picks;

        if (picks.has(cellKey)) {
            // Undo misclick
            picks.delete(cellKey);
            liveCells.delete(cellKey);
        } else if (picks.size < MAX_PICKS) {
            // Add new pick
            picks.add(cellKey);
            liveCells.add(cellKey);
        }
        updateTurnUI();
        drawGrid();
    }

    function handleKeyPress(event) {
        if (event.code === "Space" && turnPhase === "running") {
            running ? pausePending = true : startGame();
        }
    }

    function handleDoneClick(event) {
        event.stopPropagation(); // Stop click bubbling to handleClick
        if (turnPhase === "team2") {
            turnPhase = "team1";
            updateTurnUI();
        } else if (turnPhase === "team1") {
            turnPhase = "running";
            team2Picks.clear();
            team1Picks.clear();
            startGame();
        }
    }

    function createHomeBases() {
        // Team 1 (Red) base: top-right
        placePattern(1, NUM_CELLS_IN_ROW - 3, -1, block); 
        // Team 2 (Blue) base: bottom-left
        placePattern(2, -1, NUM_CELLS_IN_ROW - 3, block); 
        drawGrid();
    }

    function initialState() {
        // Draw grid, seed, bases, start with Blue's turn
        drawGrid();
        setTimeout(() => {
            randomSeed();
            createHomeBases();
            updateTurnUI(); // Show Blue's turn
            drawGrid();
        }, 0);
    }

    function randomSeed() {
        // Seed with random static patterns (Team 0)
        const patterns = [
            block,
        ];
        const numPatterns = Math.floor(Math.random() * NUM_STATICS_AT_START) + 5; 
        for (let i = 0; i < numPatterns; i++) {
            const pattern = patterns[Math.floor(Math.random() * patterns.length)];
            const xBase = Math.floor(Math.random() * (NUM_CELLS_IN_ROW - 3));
            const yBase = Math.floor(Math.random() * (NUM_CELLS_IN_ROW - 3));
            // Avoid base zones
            if ((xBase >= NUM_CELLS_IN_ROW - 3 - BASE_BUFFER && yBase <= 3 + BASE_BUFFER) || 
                (xBase <= 3 + BASE_BUFFER && yBase >= NUM_CELLS_IN_ROW - 3 - BASE_BUFFER)) continue;
            placePattern(0, xBase, yBase, pattern);
        }
    }

    function updateStatusBar() {
        // Count live cells by team and update UI
        const teamCounts = { 0: 0, 1: 0, 2: 0 };
        for (let cell of liveCells) {
            const t = parseInt(cell.split(",")[0]);
            teamCounts[t]++;
        }
        const totalLive = liveCells.size || 1; 
        const perc0 = ((teamCounts[0] / totalLive) * 100).toFixed(1);
        const perc1 = ((teamCounts[1] / totalLive) * 100).toFixed(1);
        const perc2 = ((teamCounts[2] / totalLive) * 100).toFixed(1);

        generationSpan.textContent = `Generation: ${generation}`;
        team0Span.textContent = `Neutral: ${perc0}%`;
        team1Span.textContent = `Red: ${perc1}%`;
        team2Span.textContent = `Blue: ${perc2}%`;
    }

    function updateTurnUI() {
        // Update sidebar with turn info
        if (turnPhase === "running") {
            turnInfo.textContent = "";
            doneButton.style.display = "none";
        } else {
            const teamName = turnPhase === "team2" ? "Blue" : "Red";
            const picks = turnPhase === "team2" ? team2Picks : team1Picks;
            turnInfo.textContent = `${teamName}'s Turn (${picks.size}/${MAX_PICKS} picked)`;
            doneButton.style.display = "block";
        }
    }

    function placePattern(team, xBase, yBase, pattern) {
        // Place a pattern at (xBase, yBase) - isAlive 1 = live (team), 0 = dead
        for (let [isAlive, dx, dy] of pattern) {
            const x = xBase + dx;
            const y = yBase + dy;
            if (isAlive === 0) {
                // Dead cell: clear all teams
                for (let t = 0; t <= 2; t++) {
                    liveCells.delete(`${t},${x},${y}`);
                }
            } else {
                // Live cell: set team
                liveCells.add(`${team},${x},${y}`);
            }
        }
    }

    function countNeighborsForAll() {
        // Count how many live cells neighbor each position in one pass
        const neighborCounts = new Map(); 
        for (let cell of liveCells) {
            const [t, x, y] = cell.split(",").map(Number);
            for (let xOffset = -1; xOffset <= 1; xOffset++) {
                for (let yOffset = -1; yOffset <= 1; yOffset++) {
                    if (xOffset === 0 && yOffset === 0) continue;
                    const coords = `${x + xOffset},${y + yOffset}`;
                    const counts = neighborCounts.get(coords) || { 0: 0, 1: 0, 2: 0 };
                    counts[t]++;
                    neighborCounts.set(coords, counts);
                }
            }
        }
        return neighborCounts;
    }

    function updateCells() {
        const newCells = new Set();
        const deadNeighbors = getDeadNeighbors();
        const neighborCounts = countNeighborsForAll();

        // Rebirth: Assign team by majority, random if tied
        for (let cell of deadNeighbors) {
            const counts = neighborCounts.get(cell) || { 0: 0, 1: 0, 2: 0 };
            const total = counts[0] + counts[1] + counts[2];
            if (DEAD_REBORN.includes(total)) {
                let maxTeam = 0, maxCount = counts[0];
                if (counts[1] > maxCount) { maxTeam = 1; maxCount = counts[1]; }
                if (counts[2] > maxCount) { maxTeam = 2; }
                if (counts[0] === counts[1] || counts[1] === counts[2] || counts[0] === counts[2]) {
                    const tiedTeams = [];
                    if (counts[0] > 0) tiedTeams.push(0);
                    if (counts[1] > 0) tiedTeams.push(1);
                    if (counts[2] > 0) tiedTeams.push(2);
                    maxTeam = tiedTeams[Math.floor(Math.random() * tiedTeams.length)];
                }
                newCells.add(`${maxTeam},${cell}`);
            }
        }

        // Survival: Custom rules for 2 neighbors, majority for 3
        for (let cell of liveCells) {
            const [t, x, y] = cell.split(",").map(Number);
            const coords = `${x},${y}`;
            const counts = neighborCounts.get(coords) || { 0: 0, 1: 0, 2: 0 };
            const total = counts[0] + counts[1] + counts[2];
            if (LIVE_SURVIVE.includes(total)) {
                let newTeam = t; 
                if (total === 2) {
                    const neighbors = [];
                    if (counts[0] > 0) neighbors.push(...Array(counts[0]).fill(0));
                    if (counts[1] > 0) neighbors.push(...Array(counts[1]).fill(1));
                    if (counts[2] > 0) neighbors.push(...Array(counts[2]).fill(2));
                    if (neighbors[0] === neighbors[1] && neighbors[0] !== t) {
                        // Both same, different from live: flip
                        newTeam = neighbors[0];
                    } else if (neighbors[0] !== neighbors[1] && neighbors[0] !== t && neighbors[1] !== t) {
                        // Both different, different from live: random
                        newTeam = neighbors[Math.floor(Math.random() * 2)];
                    } // Else: tied (1-1) and live is one → stay t
                } else if (total === 3) {
                    // Majority or keep if tied (previous logic)
                    let maxTeam = t, maxCount = counts[t];
                    if (counts[0] > maxCount) { maxTeam = 0; maxCount = counts[0]; }
                    if (counts[1] > maxCount && counts[1] > counts[t]) { maxTeam = 1; }
                    if (counts[2] > maxCount && counts[2] > counts[t]) { maxTeam = 2; }
                    newTeam = maxTeam;
                }
                newCells.add(`${newTeam},${x},${y}`);
            }
        }

        liveCells = newCells;
        updateStatusBar();
    }

    function gameLoop() {
        if (turnPhase === "running") {
            generation++;
            updateCells();
            drawGrid();
            if (generation % GENERATIONS_BETWEEN_TURNS === 0) {
                stopGame();
                turnPhase = "team2"; // Blue goes first
                updateTurnUI();
            }
            updateStatusBar();
        } else {
            drawGrid(); // Just draw during turns, no update
        }
        if (pausePending) {
            stopGame();
            pausePending = false;
        }
    }

    function startGame() {
        if (!running && turnPhase === "running") {
            intervalId = setInterval(gameLoop, GENERATION_LENGTH);
            running = true;
        }
    }

    function stopGame() {
        if (running) {
            clearInterval(intervalId);
            running = false;
        }
    }

    function drawGridLines() {
        ctx.strokeStyle = GRID_LINE_COLOR;
        ctx.lineWidth = 1;
        for (let x = 0; x <= canv.width; x += CELL_SIZE) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canv.height);
            ctx.stroke();
        }
        for (let y = 0; y <= canv.height; y += CELL_SIZE) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canv.width, y);
            ctx.stroke();
        }
    }

    function drawCell(t, x, y) {
        ctx.fillStyle = t === 0 ? CELL_COLOR_0 : t === 1 ? CELL_COLOR_1 : CELL_COLOR_2;
        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
    }

    function drawGrid() {
        // Clear the canvas
        ctx.fillStyle = GRID_BACKGROUND_COLOR;
        ctx.fillRect(0, 0, canv.width, canv.height);

        // Draw the grid structure
        drawGridLines();

        // Draw all live cells
        for (let cell of liveCells) {
            const [t, x, y] = cell.split(",").map(Number);
            drawCell(t, x, y);
        }
        updateStatusBar(); 
    }

    function getDeadNeighbors() {
        const dead = new Set();
        for (let cell of liveCells) {
            const [t, x, y] = cell.split(",").map(Number);
            // neighboring cells are one to the left or right (or above or below)
            for (let xOffset = -1; xOffset <= 1; xOffset++) {
                for (let yOffset = -1; yOffset <= 1; yOffset++) {
                    // this is not a neighbor, but the center cell
                    if (xOffset === 0 && yOffset === 0) continue;

                    const coords = `${x + xOffset},${y + yOffset}`;
                    const neighborKeys = [`0,${coords}`, `1,${coords}`, `2,${coords}`];
                    if (!neighborKeys.some(key => liveCells.has(key))) dead.add(coords);
                }
            }
        }
        return dead;
    }

    // Public API
    return { init };
})();

window.onload = () => GameOfLife.init();
</script>