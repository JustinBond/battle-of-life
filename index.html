<div style="display: flex;">
    <div id="sidebar" style="width: 200px; height: 830px; background: #e0e0e0;"></div>
    <div>
        <div id="status-bar" style="width: 800px; height: 30px; background: #f0f0f0; text-align: center; line-height: 30px; font-family: Arial, sans-serif;">
            <span id="generation">Generation: 0</span> |
            <span id="team0">Neutral: 0%</span> |
            <span id="team1">Red: 0%</span> |
            <span id="team2">Blue: 0%</span>
        </div>
        <canvas id="gc" width="800" height="800" style="display: block;"></canvas>
    </div>
</div>
<script>
// using old-school module pattern for lightweight way to handle scope problems
const GameOfLife = (function () {
    // Private state
    let liveCells = new Set();
    let running = false;
    let pausePending = false;
    let intervalId = null;

    // DOM setup (private)
    const canv = document.getElementById("gc");
    const ctx = canv.getContext("2d");
    const CELL_SIZE = 10
    const NUM_CELLS_IN_ROW = canv.width / CELL_SIZE;
    const LOWER_BOUND = -50;
    const UPPER_BOUND = NUM_CELLS_IN_ROW + (-1 * LOWER_BOUND);

    // game logic constants
    const LIVE_SURVIVE = [2, 3];
    const DEAD_REBORN = [3];
    const GENERATION_LENGTH = 50;
    const INITIAL_GENERATIONS = 0;

    // UI consants
    const CELL_COLOR_0 = "Black";
    const CELL_COLOR_1 = "Red";
    const CELL_COLOR_2 = "Blue";
    const GRID_LINE_COLOR = "DarkGray";
    const GRID_BACKGROUND_COLOR = "Beige";


    // Initialize the game
    function init() {
        document.addEventListener("click", handleClick);
        document.addEventListener("keydown", handleKeyPress);
        initialState();
    }

    // Event handlers
    function handleClick(event) {
        if (running) return;
        const rect = canv.getBoundingClientRect();
        const x = Math.floor((event.clientX - rect.left) / CELL_SIZE);
        const y = Math.floor((event.clientY - rect.top) / CELL_SIZE);
        const cellKey = `0,${x},${y}`;
        liveCells.has(cellKey) ? liveCells.delete(cellKey) : liveCells.add(cellKey);
        drawGrid();
    }

    function handleKeyPress(event) {
        if (event.code === "Space") {
            running ? pausePending = true : startGame();
        }
    }

    function createHomeBases() {
        const homeBasePattern = [
            [0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 0, 3], // Top row
            [0, 1, 0], [1, 1, 1], [1, 1, 2], [0, 1, 3], // Live row 1
            [0, 2, 0], [1, 2, 1], [1, 2, 2], [0, 2, 3], // Live row 2
            [0, 3, 0], [0, 3, 1], [0, 3, 2], [0, 3, 3]  // Bottom row
        ];
        // Team 1 (Red) base: top-right
        placePattern(1, NUM_CELLS_IN_ROW - 3, -1, homeBasePattern); 

        // Team 2 (Blue) base: bottom-left
        placePattern(2, -1, NUM_CELLS_IN_ROW - 3, homeBasePattern); 
        console.log("placed home bases")
        drawGrid();
    }

    function initialState() {
        drawGrid();
        setTimeout(() => {
            randomStart();
            drawGrid();
            let i = 0;
            function step() {
                if (i < INITIAL_GENERATIONS) {
                    console.log(i)
                    i++;
                    updateCells();
                    drawGrid()
                    setTimeout(step, 0); 
                }
                else {
                    createHomeBases();
                }
            }
            step();
        }, 0);

    }

    function randomStart() {
        let density = Math.random();
        for (let x = 0; x < NUM_CELLS_IN_ROW; x++) {
            for (let y = 0; y < NUM_CELLS_IN_ROW; y++) {
                if (Math.random() < density) {
                    liveCells.add(`0,${x},${y}`);
                }
            }
        }
    }

    function countNeighborsForAll() {
        // Count how many live cells neighbor each position in one pass
        const neighborCounts = new Map(); // "x,y" -> { 0: n, 1: n, 2: n }
        for (let cell of liveCells) {
            const [t, x, y] = cell.split(",").map(Number);
            for (let xOffset = -1; xOffset <= 1; xOffset++) {
                for (let yOffset = -1; yOffset <= 1; yOffset++) {
                    if (xOffset === 0 && yOffset === 0) continue;
                    const coords = `${x + xOffset},${y + yOffset}`;
                    const counts = neighborCounts.get(coords) || { 0: 0, 1: 0, 2: 0 };
                    counts[t]++;
                    neighborCounts.set(coords, counts);
                }
            }
        }
        return neighborCounts;
    }

    function updateCells() {
        const newCells = new Set();
        const deadNeighbors = getDeadNeighbors();
        const neighborCounts = countNeighborsForAll();

        // Rebirth: Assign team by majority, random if tied
        for (let cell of deadNeighbors) {
            const counts = neighborCounts.get(cell) || { 0: 0, 1: 0, 2: 0 };
            const total = counts[0] + counts[1] + counts[2];
            if (DEAD_REBORN.includes(total)) {
                let maxTeam = 0, maxCount = counts[0];
                if (counts[1] > maxCount) { maxTeam = 1; maxCount = counts[1]; }
                if (counts[2] > maxCount) { maxTeam = 2; }
                if (counts[0] === counts[1] || counts[1] === counts[2] || counts[0] === counts[2]) {
                    const tiedTeams = [];
                    if (counts[0] > 0) tiedTeams.push(0);
                    if (counts[1] > 0) tiedTeams.push(1);
                    if (counts[2] > 0) tiedTeams.push(2);
                    maxTeam = tiedTeams[Math.floor(Math.random() * tiedTeams.length)];
                }
                newCells.add(`${maxTeam},${cell}`);
            }
        }

        // Survival: Custom rules for 2 neighbors, majority for 3
        for (let cell of liveCells) {
            const [t, x, y] = cell.split(",").map(Number);
            const coords = `${x},${y}`;
            const counts = neighborCounts.get(coords) || { 0: 0, 1: 0, 2: 0 };
            const total = counts[0] + counts[1] + counts[2];
            if (LIVE_SURVIVE.includes(total)) {
                let newTeam = t; // Default: keep current
                if (total === 2) {
                    const neighbors = [];
                    if (counts[0] > 0) neighbors.push(...Array(counts[0]).fill(0));
                    if (counts[1] > 0) neighbors.push(...Array(counts[1]).fill(1));
                    if (counts[2] > 0) neighbors.push(...Array(counts[2]).fill(2));

                    if (neighbors[0] === neighbors[1] && neighbors[0] !== t) {
                        // Both same, different from live: flip
                        newTeam = neighbors[0];
                    } else if (neighbors[0] !== neighbors[1] && neighbors[0] !== t && neighbors[1] !== t) {
                        // Both different, different from live: random
                        newTeam = neighbors[Math.floor(Math.random() * 2)];
                    } // Else: tied (1-1) and live is one â†’ stay t
                } else if (total === 3) {
                    // Majority or keep if tied (previous logic)
                    let maxTeam = t, maxCount = counts[t];
                    if (counts[0] > maxCount) { maxTeam = 0; maxCount = counts[0]; }
                    if (counts[1] > maxCount && counts[1] > counts[t]) { maxTeam = 1; }
                    if (counts[2] > maxCount && counts[2] > counts[t]) { maxTeam = 2; }
                    newTeam = maxTeam;
                }
                newCells.add(`${newTeam},${x},${y}`);
            }
        }

        liveCells = newCells;
    }

    function placePattern(team, xBase, yBase, pattern) {
        // Place a pattern at (xBase, yBase) - isAlive 1 = live (team), 0 = dead
        for (let [isAlive, dx, dy] of pattern) {
            const x = xBase + dx;
            const y = yBase + dy;
            if (isAlive === 0) {
                // Dead cell: clear all teams
                for (let t = 0; t <= 2; t++) {
                    liveCells.delete(`${t},${x},${y}`);
                }
            } else {
                // Live cell: set team
                liveCells.add(`${team},${x},${y}`);
            }
        }
    }

    function gameLoop() {
        drawGrid();
        if (pausePending) {
            stopGame();
            pausePending = false;
            return;
        }
        updateCells();
    }

    function startGame() {
        if (!running) {
            intervalId = setInterval(gameLoop, GENERATION_LENGTH);
            running = true;
        }
    }

    function stopGame() {
        if (running) {
            clearInterval(intervalId);
            running = false;
        }
    }

    function drawGridLines() {
        ctx.strokeStyle = GRID_LINE_COLOR
        ctx.lineWidth = 1;
        for (let x = 0; x <= canv.width; x += CELL_SIZE) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canv.height);
            ctx.stroke();
        }
        for (let y = 0; y <= canv.height; y += CELL_SIZE) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canv.width, y);
            ctx.stroke();
        }
    }

    function drawCell(t, x, y) {
        ctx.fillStyle = t === 0 ? CELL_COLOR_0 : t === 1 ? CELL_COLOR_1 : CELL_COLOR_2;
        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
    }

    function drawGrid() {
        // Clear the canvas
        ctx.fillStyle = GRID_BACKGROUND_COLOR;
        ctx.fillRect(0, 0, canv.width, canv.height);

        // Draw the grid structure
        drawGridLines();

        // Draw all live cells
        for (let cell of liveCells) {
            const [t, x, y] = cell.split(",").map(Number);
            drawCell(t, x, y);
        }
    }


    function getDeadNeighbors() {
        const dead = new Set();
        for (let cell of liveCells) {
            const [t, x, y] = cell.split(",").map(Number);
            // neighboring cells are one to the left or right (or above or below)
            for (let xOffset = -1; xOffset <= 1; xOffset++) {
                for (let yOffset = -1; yOffset <= 1; yOffset++) {
                    // this is not a neighbor, but the center cell
                    if (xOffset === 0 && yOffset === 0) continue;

                    const coords = `${x + xOffset},${y + yOffset}`;
                    const neighborKeys = [`0,${coords}`, `1,${coords}`, `2,${coords}`];
                    if (!neighborKeys.some(key => liveCells.has(key))) dead.add(coords);
                }
            }
        }
        return dead;
    }

    // Public API
    return { init };
})();

window.onload = () => GameOfLife.init();
</script>