<div style="display: flex;">
    <div id="sidebar" style="width: 200px; height: 810px; background: #e0e0e0; padding: 10px; font-family: Arial, sans-serif;">
        <div id="pattern-list">
            <button id="glider-btn" style="width: 100%; margin-bottom: 5px;">Glider</button>
            <button id="block-btn" style="width: 100%; margin-bottom: 5px;">Block</button>
        </div>
        <div id="turn-info" style="margin-top: 10px;"></div>
    </div>
    <div>
        <div id="status-bar" style="width: 800px; height: 30px; background: #f0f0f0; text-align: center; line-height: 30px; font-family: Arial, sans-serif;">
            <span id="generation">Generation: 0</span> |
            <span id="team0">Neutral: 0%</span> |
            <span id="team1">Red: 0%</span> |
            <span id="team2">Blue: 0%</span>
        </div>
        <canvas id="gc" width="800" height="800" style="display: block;"></canvas>
    </div>
</div>
<script>
// using old-school module pattern for lightweight way to handle scope problems
const GameOfLife = (function () {
    // game logic constants
    const LIVE_SURVIVE = [2, 3];
    const DEAD_REBORN = [3];
    const GENERATION_LENGTH = 50;
    const GENERATIONS_BETWEEN_TURNS = 50;
    const BASE_BUFFER = 30;
    const MAX_PICKS = 1; // One pattern per turn
    // not technically number of statics, but close enough
    const NUM_STATICS_AT_START = 30;

    // Private state
    let liveCells = new Set();
    let running = false;
    let pausePending = false;
    let intervalId = null;
    let generation = 0;
    let turnPhase = "team2"; // Start with Blue's turn
    let selectedPattern = null;
    let previewCells = new Set(); // Temp cells for rotation preview
    let previewBaseX = 0;
    let previewBaseY = 0;
    let rotation = 0; // 0, 1, 2, 3 (0째, 90째, 180째, 270째)
    let flipped = false; // Horizontal flip toggle
    let team1LegalCells = new Set(); // Red's chain
    let team2LegalCells = new Set(); // Blue's chain

    // DOM setup (private)
    const canv = document.getElementById("gc");
    const ctx = canv.getContext("2d");
    const CELL_SIZE = 10;
    const NUM_CELLS_IN_ROW = canv.width / CELL_SIZE;
    const LOWER_BOUND = -50;
    const UPPER_BOUND = NUM_CELLS_IN_ROW + (-1 * LOWER_BOUND);

    // UI DOM refs
    const generationSpan = document.getElementById("generation");
    const team0Span = document.getElementById("team0");
    const team1Span = document.getElementById("team1");
    const team2Span = document.getElementById("team2");
    const turnInfo = document.getElementById("turn-info");
    const gliderBtn = document.getElementById("glider-btn");
    const blockBtn = document.getElementById("block-btn");

    // UI constants
    const CELL_COLOR_0 = "Black";
    const CELL_COLOR_1 = "Red";
    const CELL_COLOR_2 = "Blue";
    const GRID_LINE_COLOR = "DarkGray";
    const GRID_BACKGROUND_COLOR = "Beige";
    const TEAM1_LEGAL_COLOR = "rgba(255, 192, 203, 0.3)"; // Pink for Red
    const TEAM2_LEGAL_COLOR = "rgba(173, 216, 230, 0.3)"; // Light Blue for Blue

    // patterns (2D arrays: 1 = live, 0 = dead)
    const block = [
        [1, 1],
        [1, 1]
    ];
    const glider = [
        [0, 1, 0],
        [0, 0, 1],
        [1, 1, 1]
    ];

    // Initialize the game
    function init() {
        document.addEventListener("click", handleClick);
        document.addEventListener("keydown", handleKeyPress);
        gliderBtn.addEventListener("click", (e) => selectPattern(e, glider));
        blockBtn.addEventListener("click", (e) => selectPattern(e, block));
        initialState();
    }

    // Event handlers
    function handleClick(event) {
        if (running || turnPhase === "running" || event.target !== canv) return;
        const rect = canv.getBoundingClientRect();
        const x = Math.floor((event.clientX - rect.left) / CELL_SIZE);
        const y = Math.floor((event.clientY - rect.top) / CELL_SIZE);
        const team = turnPhase === "team2" ? 2 : 1;
        const legalCells = turnPhase === "team2" ? team2LegalCells : team1LegalCells;

        if (selectedPattern) {
            // Place or move preview if legal
            if (isLegalPlacement(team, x, y, selectedPattern, legalCells)) {
                clearPreview();
                previewBaseX = x;
                previewBaseY = y;
                placePatternPreview(team, x, y, selectedPattern, rotation, flipped);
                updateTurnUI();
                drawGrid();
            }
        }
    }

    function handleKeyPress(event) {
        if (event.code === "Space" && turnPhase === "running") {
            running ? pausePending = true : startGame();
        } else if (previewCells.size > 0) {
            const team = turnPhase === "team2" ? 2 : 1;
            const legalCells = turnPhase === "team2" ? team2LegalCells : team1LegalCells;
            if (event.code === "Enter") {
                // Confirm placement
                previewCells.forEach(cell => liveCells.add(cell));
                clearPreview();
                updateLegalCells();
                turnPhase = turnPhase === "team2" ? "team1" : "running";
                if (turnPhase === "running") {
                    startGame();
                }
                updateTurnUI();
                drawGrid();
            } else if (event.code === "ArrowLeft") {
                // Rotate counterclockwise
                rotation = (rotation - 1 + 4) % 4;
                clearPreview();
                if (isLegalPlacement(team, previewBaseX, previewBaseY, selectedPattern, legalCells)) {
                    placePatternPreview(team, previewBaseX, previewBaseY, selectedPattern, rotation, flipped);
                }
                updateTurnUI();
                drawGrid();
            } else if (event.code === "ArrowRight") {
                // Rotate clockwise
                rotation = (rotation + 1) % 4;
                clearPreview();
                if (isLegalPlacement(team, previewBaseX, previewBaseY, selectedPattern, legalCells)) {
                    placePatternPreview(team, previewBaseX, previewBaseY, selectedPattern, rotation, flipped);
                }
                updateTurnUI();
                drawGrid();
            } else if (event.code === "ArrowUp") {
                // Flip vertically (not horizontal for now)
                flipped = !flipped;
                clearPreview();
                if (isLegalPlacement(team, previewBaseX, previewBaseY, selectedPattern, legalCells)) {
                    placePatternPreview(team, previewBaseX, previewBaseY, selectedPattern, rotation, flipped);
                }
                updateTurnUI();
                drawGrid();
            } else if (event.code === "ArrowDown") {
                // Flip vertically again (toggle)
                flipped = !flipped;
                clearPreview();
                if (isLegalPlacement(team, previewBaseX, previewBaseY, selectedPattern, legalCells)) {
                    placePatternPreview(team, previewBaseX, previewBaseY, selectedPattern, rotation, flipped);
                }
                updateTurnUI();
                drawGrid();
            }
        }
    }

    function selectPattern(event, pattern) {
        event.stopPropagation(); // Stop bubbling to handleClick
        if (turnPhase !== "running" && previewCells.size === 0) {
            selectedPattern = pattern;
            updateLegalCells(); // Update buffer after picking pattern
            updateTurnUI();
            drawGrid();
        }
    }

    function createHomeBases() {
        // Team 1 (Red) base: top-right
        placePattern(1, NUM_CELLS_IN_ROW - 2, 0, block);
        // Team 2 (Blue) base: bottom-left
        placePattern(2, 0, NUM_CELLS_IN_ROW - 2, block);
        drawGrid();
    }

    function initialState() {
        // Draw grid, seed, bases, start with Blue's turn
        drawGrid();
        setTimeout(() => {
            randomSeed();
            createHomeBases();
            updateTurnUI();
            drawGrid();
        }, 0);
    }

    function randomSeed() {
        // Seed with random static patterns (Team 0)
        const patterns = [block];
        const numPatterns = Math.floor(Math.random() * NUM_STATICS_AT_START) + 5;
        for (let i = 0; i < numPatterns; i++) {
            const pattern = patterns[Math.floor(Math.random() * patterns.length)];
            const xBase = Math.floor(Math.random() * (NUM_CELLS_IN_ROW - 3));
            const yBase = Math.floor(Math.random() * (NUM_CELLS_IN_ROW - 3));
            // Avoid base zones
            if ((xBase >= NUM_CELLS_IN_ROW - 3 - BASE_BUFFER && yBase <= 3 + BASE_BUFFER) || 
                (xBase <= 3 + BASE_BUFFER && yBase >= NUM_CELLS_IN_ROW - 3 - BASE_BUFFER)) continue;
            placePattern(0, xBase, yBase, pattern);
        }
    }

    function updateStatusBar() {
        // Count live cells by team and update UI
        const teamCounts = { 0: 0, 1: 0, 2: 0 };
        for (let cell of liveCells) {
            const t = parseInt(cell.split(",")[0]);
            teamCounts[t]++;
        }
        const totalLive = liveCells.size || 1;
        const perc0 = ((teamCounts[0] / totalLive) * 100).toFixed(1);
        const perc1 = ((teamCounts[1] / totalLive) * 100).toFixed(1);
        const perc2 = ((teamCounts[2] / totalLive) * 100).toFixed(1);

        generationSpan.textContent = `Generation: ${generation}`;
        team0Span.textContent = `Neutral: ${perc0}%`;
        team1Span.textContent = `Red: ${perc1}%`;
        team2Span.textContent = `Blue: ${perc2}%`;
    }

    function updateTurnUI() {
        // Update sidebar with turn info
        if (turnPhase === "running") {
            turnInfo.textContent = "";
        } else if (previewCells.size === 0) {
            const teamName = turnPhase === "team2" ? "Blue" : "Red";
            turnInfo.textContent = `${teamName}'s Turn: Pick a pattern`;
        } else {
            const teamName = turnPhase === "team2" ? "Blue" : "Red";
            turnInfo.textContent = `${teamName}'s Turn: Click to move, Arrows to rotate/flip, Enter to accept`;
        }
    }

    function placePattern(team, xBase, yBase, pattern) {
        // Place a pattern at (xBase, yBase) - iterate 2D array
        for (let i = 0; i < pattern.length; i++) {
            for (let j = 0; j < pattern[i].length; j++) {
                const x = xBase + j;
                const y = yBase + i;
                if (pattern[i][j] === 1) {
                    liveCells.add(`${team},${x},${y}`);
                } else {
                    for (let t = 0; t <= 2; t++) {
                        liveCells.delete(`${t},${x},${y}`);
                    }
                }
            }
        }
    }

    function placePatternPreview(team, xBase, yBase, pattern, rot, flip) {
        // Place a preview pattern with rotation and flip
        previewCells.clear();
        let grid = pattern;
        
        // Rotate pattern
        for (let r = 0; r < rot; r++) {
            const newGrid = [];
            for (let j = 0; j < grid[0].length; j++) {
                const row = [];
                for (let i = grid.length - 1; i >= 0; i--) {
                    row.push(grid[i][j]);
                }
                newGrid.push(row);
            }
            grid = newGrid;
        }
        
        // Flip vertically if toggled
        if (flip) {
            grid = grid.map(row => [...row].reverse());
        }

        // Place rotated/flipped pattern
        for (let i = 0; i < grid.length; i++) {
            for (let j = 0; j < grid[i].length; j++) {
                const x = xBase + j;
                const y = yBase + i;
                if (grid[i][j] === 1) {
                    previewCells.add(`${team},${x},${y}`);
                }
            }
        }
    }

    function clearPreview() {
        previewCells.clear();
    }

    function updateLegalCells() {
        // Flood-fill from team-owned cells with exact pattern size
        team1LegalCells.clear();
        team2LegalCells.clear();

        const team1Base = new Set([
            `1,${NUM_CELLS_IN_ROW - 2},0`, `1,${NUM_CELLS_IN_ROW - 2},1`,
            `1,${NUM_CELLS_IN_ROW - 1},0`, `1,${NUM_CELLS_IN_ROW - 1},1`
        ]);
        const team2Base = new Set([
            `2,0,${NUM_CELLS_IN_ROW - 2}`, `2,0,${NUM_CELLS_IN_ROW - 1}`,
            `2,1,${NUM_CELLS_IN_ROW - 2}`, `2,1,${NUM_CELLS_IN_ROW - 1}`
        ]);

        function floodFill(team, baseCells, legalCells) {
            const queue = [...baseCells];
            const visited = new Set();
            const height = selectedPattern ? selectedPattern.length : 2; // Rows
            const width = selectedPattern ? selectedPattern[0].length : 2; // Cols
            const halfHeight = Math.floor(height / 2);
            const halfWidth = Math.floor(width / 2);

            while (queue.length > 0) {
                const cell = queue.shift();
                const [t, x, y] = cell.split(",").map(Number);
                const coord = `${x},${y}`;
                if (visited.has(coord)) continue;
                visited.add(coord);

                // Add to legal cells if owned by team or base
                if (liveCells.has(cell) || baseCells.has(cell)) {
                    // Expand to exact pattern size around owned cell
                    for (let dx = -halfWidth; dx < width - halfWidth; dx++) {
                        for (let dy = -halfHeight; dy < height - halfHeight; dy++) {
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx >= 0 && nx < NUM_CELLS_IN_ROW && ny >= 0 && ny < NUM_CELLS_IN_ROW) {
                                legalCells.add(`${nx},${ny}`);
                            }
                        }
                    }
                }

                // Check 4 directions with 1-cell gap
                const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                for (let [dx, dy] of dirs) {
                    for (let gap = 0; gap <= 1; gap++) {
                        const nx = x + dx * (gap + 1);
                        const ny = y + dy * (gap + 1);
                        const nextCoord = `${nx},${ny}`;
                        const nextCell = `${t},${nx},${ny}`;
                        if (nx >= 0 && nx < NUM_CELLS_IN_ROW && ny >= 0 && ny < NUM_CELLS_IN_ROW && !visited.has(nextCoord)) {
                            if (gap === 0 || liveCells.has(`${t},${x + dx},${y + dy}`)) {
                                // Only queue if next cell is team-owned or base
                                if (liveCells.has(nextCell) || baseCells.has(nextCell)) {
                                    queue.push(nextCell);
                                    visited.add(nextCoord);
                                }
                            }
                        }
                    }
                }
            }
        }

        floodFill(1, team1Base, team1LegalCells);
        floodFill(2, team2Base, team2LegalCells);
    }

    function isLegalPlacement(team, xBase, yBase, pattern, legalCells) {
        // Check if any pattern cell lands in legal area
        let grid = pattern;
        
        // Rotate pattern
        for (let r = 0; r < rotation; r++) {
            const newGrid = [];
            for (let j = 0; j < grid[0].length; j++) {
                const row = [];
                for (let i = grid.length - 1; i >= 0; i--) {
                    row.push(grid[i][j]);
                }
                newGrid.push(row);
            }
            grid = newGrid;
        }
        
        // Flip vertically if toggled
        if (flipped) {
            grid = grid.map(row => [...row].reverse());
        }

        // Check legal placement
        for (let i = 0; i < grid.length; i++) {
            for (let j = 0; j < grid[i].length; j++) {
                if (grid[i][j] === 1) {
                    const x = xBase + j;
                    const y = yBase + i;
                    if (legalCells.has(`${x},${y}`)) return true;
                }
            }
        }
        return false;
    }

    function countNeighborsForAll() {
        // Count how many live cells neighbor each position in one pass
        const neighborCounts = new Map();
        for (let cell of liveCells) {
            const [t, x, y] = cell.split(",").map(Number);
            for (let xOffset = -1; xOffset <= 1; xOffset++) {
                for (let yOffset = -1; yOffset <= 1; yOffset++) {
                    if (xOffset === 0 && yOffset === 0) continue;
                    const coords = `${x + xOffset},${y + yOffset}`;
                    const counts = neighborCounts.get(coords) || { 0: 0, 1: 0, 2: 0 };
                    counts[t]++;
                    neighborCounts.set(coords, counts);
                }
            }
        }
        return neighborCounts;
    }

    function updateCells() {
        const newCells = new Set();
        const deadNeighbors = getDeadNeighbors();
        const neighborCounts = countNeighborsForAll();

        // Rebirth: Assign team by majority, random if tied
        for (let cell of deadNeighbors) {
            const counts = neighborCounts.get(cell) || { 0: 0, 1: 0, 2: 0 };
            const total = counts[0] + counts[1] + counts[2];
            if (DEAD_REBORN.includes(total)) {
                let maxTeam = 0, maxCount = counts[0];
                if (counts[1] > maxCount) { maxTeam = 1; maxCount = counts[1]; }
                if (counts[2] > maxCount) { maxTeam = 2; }
                if (counts[0] === counts[1] || counts[1] === counts[2] || counts[0] === counts[2]) {
                    const tiedTeams = [];
                    if (counts[0] > 0) tiedTeams.push(0);
                    if (counts[1] > 0) tiedTeams.push(1);
                    if (counts[2] > 0) tiedTeams.push(2);
                    maxTeam = tiedTeams[Math.floor(Math.random() * tiedTeams.length)];
                }
                newCells.add(`${maxTeam},${cell}`);
            }
        }

        // Survival: Custom rules for 2 neighbors, majority for 3
        for (let cell of liveCells) {
            const [t, x, y] = cell.split(",").map(Number);
            const coords = `${x},${y}`;
            const counts = neighborCounts.get(coords) || { 0: 0, 1: 0, 2: 0 };
            const total = counts[0] + counts[1] + counts[2];
            if (LIVE_SURVIVE.includes(total)) {
                let newTeam = t;
                if (total === 2) {
                    const neighbors = [];
                    if (counts[0] > 0) neighbors.push(...Array(counts[0]).fill(0));
                    if (counts[1] > 0) neighbors.push(...Array(counts[1]).fill(1));
                    if (counts[2] > 0) neighbors.push(...Array(counts[2]).fill(2));
                    if (neighbors[0] === neighbors[1] && neighbors[0] !== t) {
                        newTeam = neighbors[0];
                    } else if (neighbors[0] !== neighbors[1] && neighbors[0] !== t && neighbors[1] !== t) {
                        newTeam = neighbors[Math.floor(Math.random() * 2)];
                    }
                } else if (total === 3) {
                    let maxTeam = t, maxCount = counts[t];
                    if (counts[0] > maxCount) { maxTeam = 0; maxCount = counts[0]; }
                    if (counts[1] > maxCount && counts[1] > counts[t]) { maxTeam = 1; }
                    if (counts[2] > maxCount && counts[2] > counts[t]) { maxTeam = 2; }
                    newTeam = maxTeam;
                }
                newCells.add(`${newTeam},${x},${y}`);
            }
        }

        liveCells = newCells;
        updateStatusBar();
    }

    function gameLoop() {
        if (turnPhase === "running") {
            generation++;
            updateCells();
            drawGrid();
            if (generation % GENERATIONS_BETWEEN_TURNS === 0) {
                stopGame();
                turnPhase = "team2";
                updateTurnUI();
            }
            updateStatusBar();
        } else {
            drawGrid(); // Just draw during turns, no update
        }
        if (pausePending) {
            stopGame();
            pausePending = false;
        }
    }

    function startGame() {
        if (!running && turnPhase === "running") {
            intervalId = setInterval(gameLoop, GENERATION_LENGTH);
            running = true;
        }
    }

    function stopGame() {
        if (running) {
            clearInterval(intervalId);
            running = false;
        }
    }

    function drawGridLines() {
        ctx.strokeStyle = GRID_LINE_COLOR;
        ctx.lineWidth = 1;
        for (let x = 0; x <= canv.width; x += CELL_SIZE) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canv.height);
            ctx.stroke();
        }
        for (let y = 0; y <= canv.height; y += CELL_SIZE) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canv.width, y);
            ctx.stroke();
        }
    }

    function drawCell(t, x, y) {
        ctx.fillStyle = t === 0 ? CELL_COLOR_0 : t === 1 ? CELL_COLOR_1 : CELL_COLOR_2;
        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
    }

    function drawGrid() {
        // Clear the canvas
        ctx.fillStyle = GRID_BACKGROUND_COLOR;
        ctx.fillRect(0, 0, canv.width, canv.height);

        // Draw legal areas
        if (turnPhase !== "running") {
            const legalCells = turnPhase === "team2" ? team2LegalCells : team1LegalCells;
            const color = turnPhase === "team2" ? TEAM2_LEGAL_COLOR : TEAM1_LEGAL_COLOR;
            ctx.fillStyle = color;
            for (let cell of legalCells) {
                const [x, y] = cell.split(",").map(Number);
                if (x >= 0 && x < NUM_CELLS_IN_ROW && y >= 0 && y < NUM_CELLS_IN_ROW) {
                    ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
            }
        }

        // Draw the grid structure
        drawGridLines();

        // Draw all live cells
        for (let cell of liveCells) {
            const [t, x, y] = cell.split(",").map(Number);
            drawCell(t, x, y);
        }
        // Draw preview cells
        for (let cell of previewCells) {
            const [t, x, y] = cell.split(",").map(Number);
            drawCell(t, x, y);
        }
        updateStatusBar();
    }

    function getDeadNeighbors() {
        const dead = new Set();
        for (let cell of liveCells) {
            const [t, x, y] = cell.split(",").map(Number);
            // neighboring cells are one to the left or right (or above or below)
            for (let xOffset = -1; xOffset <= 1; xOffset++) {
                for (let yOffset = -1; yOffset <= 1; yOffset++) {
                    // this is not a neighbor, but the center cell
                    if (xOffset === 0 && yOffset === 0) continue;

                    const coords = `${x + xOffset},${y + yOffset}`;
                    const neighborKeys = [`0,${coords}`, `1,${coords}`, `2,${coords}`];
                    if (!neighborKeys.some(key => liveCells.has(key))) dead.add(coords);
                }
            }
        }
        return dead;
    }

    // Public API
    return { init };
})();

window.onload = () => GameOfLife.init();
</script>